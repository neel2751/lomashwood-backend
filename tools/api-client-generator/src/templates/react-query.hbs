/**
 * {{title}} — React Query Hooks
 * Version: {{version}}
 * Generated: {{generatedAt}}
 * DO NOT EDIT — regenerate with: pnpm generate
 */

import {
  useQuery,
  useMutation,
  useInfiniteQuery,
  UseQueryOptions,
  UseMutationOptions,
  UseInfiniteQueryOptions,
  QueryClient,
  QueryKey,
  keepPreviousData,
} from "@tanstack/react-query";
import { z } from "zod";

export const BASE_URL = "{{baseUrl}}";

export type ApiResponse<T> = {
  data: T;
  meta?: {
    total?: number;
    page?: number;
    limit?: number;
    totalPages?: number;
  };
  message?: string;
};

export type ApiErrorBody = {
  statusCode: number;
  message: string;
  errors?: Record<string, string[]>;
  timestamp: string;
};

export class LomashApiError extends Error {
  statusCode: number;
  errors?: Record<string, string[]>;

  constructor(body: ApiErrorBody) {
    super(body.message);
    this.name = "LomashApiError";
    this.statusCode = body.statusCode;
    this.errors = body.errors;
  }
}

{{#each models}}
export const {{name}}Schema = {{schemaToZod schema}};
export type {{name}} = z.infer<typeof {{name}}Schema>;

{{/each}}

export interface PaginationParams {
  page?: number;
  limit?: number;
  sort?: string;
  order?: "asc" | "desc";
}

export interface PaginatedData<T> {
  items: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

let _authToken: string | null = null;

export function setAuthToken(token: string | null): void {
  _authToken = token;
}

async function apiFetch<T>(
  method: string,
  path: string,
  options?: {
    body?: unknown;
    query?: Record<string, string | number | boolean | undefined | null>;
    signal?: AbortSignal;
  }
): Promise<T> {
  const url = new URL(`${BASE_URL}${path}`);

  if (options?.query) {
    for (const [key, value] of Object.entries(options.query)) {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, String(value));
      }
    }
  }

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
  };

  if (_authToken) {
    headers["Authorization"] = `Bearer ${_authToken}`;
  }

  const response = await fetch(url.toString(), {
    method,
    headers,
    body: options?.body !== undefined ? JSON.stringify(options.body) : undefined,
    signal: options?.signal,
  });

  const contentType = response.headers.get("content-type") || "";
  const responseData = contentType.includes("application/json")
    ? await response.json()
    : await response.text();

  if (!response.ok) {
    throw new LomashApiError(responseData as ApiErrorBody);
  }

  return responseData as T;
}

export const queryKeys = {
  {{#each tags}}
  {{lowerFirst (tagToPascal this)}}: {
    all: () => ["{{this}}"] as const,
    {{#each (operationsByTag ../operations ../this)}}
    {{#if (isQuery this)}}
    {{operationId}}: (
      {{#if (hasPathParams this)}}
      params?: Record<string, string | number>,
      {{/if}}
      {{#if (hasQueryParams this)}}
      query?: Record<string, unknown>
      {{/if}}
    ) => [
      "{{../this}}",
      "{{operationId}}",
      {{#if (hasPathParams this)}}params,{{/if}}
      {{#if (hasQueryParams this)}}query,{{/if}}
    ] as const,
    {{/if}}
    {{/each}}
  },
  {{/each}}
} as const;

{{#each tags}}
{{#with (operationsByTag ../operations this)}}
{{#if this.length}}

export function use{{tagToPascal ../this}}(queryClient?: QueryClient) {
  return {
  {{#each this}}
  {{#if (isQuery this)}}
  /**
   * {{summary}}{{#if deprecated}} @deprecated{{/if}}
   * @method GET {{path}}
   */
  use{{pascalCase operationId}}(
    {{#if (hasPathParams this)}}
    params: {
      {{#each (pathParams this)}}
      {{name}}: {{schemaToTs schema}};
      {{/each}}
    },
    {{/if}}
    {{#if (hasQueryParams this)}}
    query?: {
      {{#each (queryParams this)}}
      {{name}}{{#unless required}}?{{/unless}}: {{schemaToTs schema}};
      {{/each}}
    },
    {{/if}}
    options?: Omit<
      UseQueryOptions<
        {{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}},
        LomashApiError
      >,
      "queryKey" | "queryFn"
    >
  ) {
    return useQuery<
      {{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}},
      LomashApiError
    >({
      queryKey: queryKeys.{{lowerFirst (tagToPascal ../this)}}.{{operationId}}(
        {{#if (hasPathParams this)}}params,{{/if}}
        {{#if (hasQueryParams this)}}query,{{/if}}
      ),
      queryFn: ({ signal }) =>
        apiFetch<{{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}}>(
          "GET",
          `{{pathToUrl path}}`,
          {
            {{#if (hasQueryParams this)}}query: query as Record<string, string | number | boolean | undefined | null>,{{/if}}
            signal,
          }
        ),
      placeholderData: keepPreviousData,
      ...options,
    });
  },

  {{else}}
  /**
   * {{summary}}{{#if deprecated}} @deprecated{{/if}}
   * @method {{upperFirst method}} {{path}}
   */
  use{{pascalCase operationId}}(
    options?: UseMutationOptions<
      {{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}},
      LomashApiError,
      {{#if requestBody}}{{schemaToTs requestBody.schema}}{{#if (hasPathParams this)}} & {
        {{#each (pathParams this)}}
        {{name}}: {{schemaToTs schema}};
        {{/each}}
      }{{/if}}{{else}}{{#if (hasPathParams this)}}{
        {{#each (pathParams this)}}
        {{name}}: {{schemaToTs schema}};
        {{/each}}
      }{{else}}void{{/if}}{{/if}}
    >
  ) {
    return useMutation<
      {{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}},
      LomashApiError,
      {{#if requestBody}}{{schemaToTs requestBody.schema}}{{#if (hasPathParams this)}} & {
        {{#each (pathParams this)}}
        {{name}}: {{schemaToTs schema}};
        {{/each}}
      }{{/if}}{{else}}{{#if (hasPathParams this)}}{
        {{#each (pathParams this)}}
        {{name}}: {{schemaToTs schema}};
        {{/each}}
      }{{else}}void{{/if}}{{/if}}
    >({
      mutationFn: ({{#if (or requestBody (hasPathParams this))}}payload{{else}}_{{/if}}) =>
        apiFetch<{{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}}>(
          "{{upperFirst method}}",
          `{{pathToUrl path}}`,
          {
            {{#if requestBody}}body: payload,{{/if}}
          }
        ),
      ...options,
    });
  },

  {{/if}}
  {{/each}}
  };
}

{{/if}}
{{/with}}
{{/each}}

export function prefetchAll(queryClient: QueryClient): Promise<void[]> {
  const promises: Promise<void>[] = [];

  {{#each tags}}
  {{#each (operationsByTag ../operations this)}}
  {{#if (isQuery this)}}
  {{#unless (hasPathParams this)}}
  promises.push(
    queryClient.prefetchQuery({
      queryKey: queryKeys.{{lowerFirst (tagToPascal ../this)}}.{{operationId}}(),
      queryFn: () =>
        apiFetch<{{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}}>(
          "GET",
          "{{path}}"
        ),
    })
  );
  {{/unless}}
  {{/if}}
  {{/each}}
  {{/each}}

  return Promise.all(promises);
}

export function invalidateAll(queryClient: QueryClient): Promise<void> {
  return queryClient.invalidateQueries();
}

export const lomashHooks = {
  {{#each tags}}
  use{{tagToPascal this}},
  {{/each}}
  queryKeys,
  prefetchAll,
  invalidateAll,
  setAuthToken,
};

export default lomashHooks;
