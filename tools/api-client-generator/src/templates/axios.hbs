/**
 * {{title}} — Axios API Client
 * Version: {{version}}
 * Generated: {{generatedAt}}
 * DO NOT EDIT — regenerate with: pnpm generate
 */

import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  InternalAxiosRequestConfig,
} from "axios";

export const BASE_URL = "{{baseUrl}}";

export type ApiResponse<T> = {
  data: T;
  meta?: {
    total?: number;
    page?: number;
    limit?: number;
    totalPages?: number;
  };
  message?: string;
};

export type ApiErrorBody = {
  statusCode: number;
  message: string;
  errors?: Record<string, string[]>;
  timestamp: string;
  path?: string;
};

export class LomashApiError extends Error {
  statusCode: number;
  errors?: Record<string, string[]>;
  path?: string;

  constructor(body: ApiErrorBody) {
    super(body.message);
    this.name = "LomashApiError";
    this.statusCode = body.statusCode;
    this.errors = body.errors;
    this.path = body.path;
  }
}

{{#each models}}
export interface {{name}} {
  {{#each properties}}
  {{@key}}{{#unless (isRequired @key ../required)}}?{{/unless}}: {{schemaToTs this}};
  {{/each}}
}

{{/each}}

export interface PaginatedResponse<T> {
  data: T[];
  meta: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
  };
}

export interface PaginationParams {
  page?: number;
  limit?: number;
  sort?: string;
  order?: "asc" | "desc";
}

function createAxiosInstance(config?: AxiosRequestConfig): AxiosInstance {
  const instance = axios.create({
    baseURL: BASE_URL,
    timeout: 30000,
    headers: {
      "Content-Type": "application/json",
      "Accept": "application/json",
    },
    ...config,
  });

  instance.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
      const token = typeof window !== "undefined"
        ? localStorage.getItem("lomash_token")
        : null;

      if (token && config.headers) {
        config.headers["Authorization"] = `Bearer ${token}`;
      }

      return config;
    },
    (error) => Promise.reject(error)
  );

  instance.interceptors.response.use(
    (response: AxiosResponse) => response,
    async (error) => {
      const originalRequest = error.config;

      if (error.response?.status === 401 && !originalRequest._retry) {
        originalRequest._retry = true;

        try {
          const refreshToken = typeof window !== "undefined"
            ? localStorage.getItem("lomash_refresh_token")
            : null;

          if (refreshToken) {
            const { data } = await axios.post(`${BASE_URL}/v1/auth/refresh`, {
              refreshToken,
            });

            const newToken = data.data?.token;

            if (newToken && typeof window !== "undefined") {
              localStorage.setItem("lomash_token", newToken);
              originalRequest.headers["Authorization"] = `Bearer ${newToken}`;
            }

            return instance(originalRequest);
          }
        } catch {
          if (typeof window !== "undefined") {
            localStorage.removeItem("lomash_token");
            localStorage.removeItem("lomash_refresh_token");
          }
        }
      }

      if (error.response?.data) {
        throw new LomashApiError(error.response.data as ApiErrorBody);
      }

      throw error;
    }
  );

  return instance;
}

export const apiClient = createAxiosInstance();

export function setAuthToken(token: string | null): void {
  if (token) {
    apiClient.defaults.headers.common["Authorization"] = `Bearer ${token}`;
  } else {
    delete apiClient.defaults.headers.common["Authorization"];
  }
}

{{#each tags}}
export class {{tagToPascal this}}Service {
  private client: AxiosInstance;

  constructor(client: AxiosInstance = apiClient) {
    this.client = client;
  }

  {{#each (operationsByTag ../operations ../this)}}
  /**
   * {{summary}}
   {{#if description}}* {{description}}{{/if}}
   {{#if deprecated}}* @deprecated{{/if}}
   * @method {{upperFirst method}}
   * @path {{path}}
   */
  async {{operationId}}(
    {{#if (hasPathParams this)}}
    params: {
      {{#each (pathParams this)}}
      {{name}}: {{schemaToTs schema}};
      {{/each}}
    },
    {{/if}}
    {{#if requestBody}}
    body: {{schemaToTs requestBody.schema}},
    {{/if}}
    {{#if (hasQueryParams this)}}
    query?: {
      {{#each (queryParams this)}}
      {{name}}{{#unless required}}?{{/unless}}: {{schemaToTs schema}};
      {{/each}}
    },
    {{/if}}
    config?: AxiosRequestConfig
  ): Promise<{{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}}> {
    const url = `{{pathToUrl path}}`;
    const response = await this.client.{{method}}<{{#with (successResponse this)}}{{#if schema}}{{schemaToTs schema}}{{else}}void{{/if}}{{else}}void{{/with}}>(
      url,
      {{#if (or (eq method "post") (or (eq method "put") (eq method "patch")))}}
      body,
      {{/if}}
      {
        {{#if (hasQueryParams this)}}params: query,{{/if}}
        ...config,
      }
    );
    return response.data;
  }

  {{/each}}
}

export const {{lowerFirst (tagToPascal this)}}Service = new {{tagToPascal this}}Service();

{{/each}}

export const lomashApi = {
  {{#each tags}}
  {{lowerFirst (tagToPascal this)}}: {{lowerFirst (tagToPascal this)}}Service,
  {{/each}}
  setAuthToken,
  client: apiClient,
};

export default lomashApi;
