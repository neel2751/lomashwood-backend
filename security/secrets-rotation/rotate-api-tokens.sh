#!/usr/bin/env bash
# =============================================================================
# rotate-api-tokens.sh — API Tokens & Third-Party Secret Rotation
# Lomash Wood Backend — security/secrets-rotation/
#
# Document ID : LW-SEC-ROT-003
# Version     : 1.2
# Owner       : DevOps Lead
# Last Updated: 2026-02-19
#
# PURPOSE
# -------
# Rotates internal API keys and assists with third-party service secret rotation
# for all Lomash Wood external integrations. This script handles:
#
#   INTERNAL TOKENS
#   • Internal service-to-service API keys (scoped to specific microservices)
#   • Admin-provisioned API keys stored in the database
#
#   THIRD-PARTY SECRETS (semi-automated — operator must complete vendor steps)
#   • Stripe API keys (restricted + secret) — operator must create in Stripe
#   • Stripe webhook signing secret — operator must retrieve from Stripe
#   • Twilio Account SID / Auth Token — operator must create in Twilio
#   • Firebase service account key — operator must export from Firebase
#   • AWS SES SMTP credentials — auto-rotated via IAM
#   • AWS S3 / general IAM access keys — auto-rotated via IAM
#
# WORKFLOW
# --------
# Third-party keys cannot be generated by this script — they must be created in
# the vendor's dashboard first. This script:
#   1. Prompts the operator to create the new key in the vendor dashboard
#   2. Accepts the new key value interactively (or via --key-value flag in CI)
#   3. Stores it in AWS Secrets Manager
#   4. Updates the relevant Kubernetes secrets
#   5. Triggers a rolling restart of affected services
#   6. Verifies service health
#   7. Guides the operator to revoke the old key in the vendor dashboard
#
# PREREQUISITES
# -------------
#   - AWS CLI v2 (Secrets Manager + IAM access)
#   - kubectl configured for target cluster
#   - jq, openssl
#
# USAGE
# -----
#   ./rotate-api-tokens.sh [OPTIONS]
#
# OPTIONS
#   --env           Target environment: staging | production (required)
#   --token         Token to rotate (see TOKEN NAMES below)
#   --key-value     New key value (for CI/CD; interactive if omitted)
#   --list          List all managed tokens and their last rotation date
#   --audit         Show audit log for token rotations
#   --dry-run       Print actions without executing
#   --force         Skip confirmation prompts
#   --help          Show this help
#
# TOKEN NAMES (use with --token)
#   stripe-secret-key           Stripe secret key (sk_live_... / sk_test_...)
#   stripe-webhook-secret       Stripe webhook signing secret (whsec_...)
#   stripe-restricted-key       Stripe restricted key for webhook validation
#   twilio-auth-token           Twilio Account Auth Token
#   firebase-service-account    Firebase Admin SDK service account JSON
#   ses-smtp-password           AWS SES SMTP credentials (IAM-managed)
#   internal-api-key            Internal service API key (specify --service-name)
#   all-internal                Rotate all internal API keys
#
# EXAMPLES
#   ./rotate-api-tokens.sh --env staging --list
#   ./rotate-api-tokens.sh --env production --token stripe-secret-key
#   ./rotate-api-tokens.sh --env staging --token all-internal
#   ./rotate-api-tokens.sh --env production --token stripe-webhook-secret --force
#
# EXIT CODES
#   0  Success
#   1  Invalid arguments
#   2  Prerequisite check failed
#   3  Secrets Manager update failed
#   4  Kubernetes update failed
#   5  Service health check failed after restart
# =============================================================================

set -euo pipefail
IFS=$'\n\t'

# ── Constants ──────────────────────────────────────────────────────────────────
readonly SCRIPT_NAME="rotate-api-tokens.sh"
readonly SCRIPT_VERSION="1.2"
readonly TIMESTAMP=$(date -u +"%Y%m%dT%H%M%SZ")
readonly LOG_FILE="/var/log/lomash-wood/token-rotation-${TIMESTAMP}.log"
readonly AUDIT_LOG_FILE="/var/log/lomash-wood/audit.log"
readonly TMP_DIR=$(mktemp -d)
readonly ROLLOUT_TIMEOUT=300

# AWS Secrets Manager key name patterns
declare -A SECRET_NAMES=(
  ["stripe-secret-key"]="lomash-wood/{ENV}/stripe/secret-key"
  ["stripe-webhook-secret"]="lomash-wood/{ENV}/stripe/webhook-signing-secret"
  ["stripe-restricted-key"]="lomash-wood/{ENV}/stripe/restricted-key"
  ["twilio-auth-token"]="lomash-wood/{ENV}/twilio/auth-token"
  ["firebase-service-account"]="lomash-wood/{ENV}/firebase/service-account-json"
  ["ses-smtp-password"]="lomash-wood/{ENV}/ses/smtp-credentials"
  ["internal-api-key"]="lomash-wood/{ENV}/internal/{SERVICE_NAME}/api-key"
)

# Kubernetes secret keys and affected deployments
declare -A K8S_SECRET_KEYS=(
  ["stripe-secret-key"]="STRIPE_SECRET_KEY"
  ["stripe-webhook-secret"]="STRIPE_WEBHOOK_SECRET"
  ["stripe-restricted-key"]="STRIPE_RESTRICTED_KEY"
  ["twilio-auth-token"]="TWILIO_AUTH_TOKEN"
  ["firebase-service-account"]="FIREBASE_SERVICE_ACCOUNT_JSON"
  ["ses-smtp-password"]="SES_SMTP_PASSWORD"
)

declare -A AFFECTED_SERVICES=(
  ["stripe-secret-key"]="order-payment-service"
  ["stripe-webhook-secret"]="order-payment-service"
  ["stripe-restricted-key"]="order-payment-service"
  ["twilio-auth-token"]="notification-service"
  ["firebase-service-account"]="notification-service"
  ["ses-smtp-password"]="notification-service"
)

# Vendor dashboard URLs for operator guidance
declare -A VENDOR_URLS=(
  ["stripe-secret-key"]="https://dashboard.stripe.com/apikeys"
  ["stripe-webhook-secret"]="https://dashboard.stripe.com/webhooks"
  ["stripe-restricted-key"]="https://dashboard.stripe.com/apikeys"
  ["twilio-auth-token"]="https://console.twilio.com/us1/account/keys-credentials/api-keys"
  ["firebase-service-account"]="https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk"
  ["ses-smtp-password"]="https://console.aws.amazon.com/ses/home#smtp-settings:"
)

# ── Colours ────────────────────────────────────────────────────────────────────
RED='\033[0;31m'; YELLOW='\033[1;33m'; GREEN='\033[0;32m'
BLUE='\033[0;34m'; CYAN='\033[0;36m'; PURPLE='\033[0;35m'; NC='\033[0m'

# ── Argument defaults ─────────────────────────────────────────────────────────
ENV=""
TOKEN=""
KEY_VALUE=""
SERVICE_NAME=""
LIST_MODE=false
AUDIT_MODE=false
DRY_RUN=false
FORCE=false

# ── Cleanup ───────────────────────────────────────────────────────────────────
cleanup() {
  local exit_code=$?
  # Securely wipe temp files containing key material
  if [[ -d "${TMP_DIR}" ]]; then
    find "${TMP_DIR}" -type f -exec shred -u {} \; 2>/dev/null || rm -rf "${TMP_DIR}"
  fi
  [[ ${exit_code} -ne 0 ]] && log_error "Script exited with code ${exit_code}. Log: ${LOG_FILE}"
}
trap cleanup EXIT
trap 'log_error "Script interrupted."; exit 130' INT TERM

# ── Logging ───────────────────────────────────────────────────────────────────
setup_logging() {
  mkdir -p "$(dirname "${LOG_FILE}")"
  exec > >(tee -a "${LOG_FILE}") 2>&1
}

log_info()    { echo -e "${CYAN}[$(date -u +%H:%M:%SZ)] [INFO]  ${NC}$*"; _audit "INFO"  "$*"; }
log_success() { echo -e "${GREEN}[$(date -u +%H:%M:%SZ)] [OK]    ${NC}$*"; _audit "OK"    "$*"; }
log_warn()    { echo -e "${YELLOW}[$(date -u +%H:%M:%SZ)] [WARN]  ${NC}$*"; _audit "WARN"  "$*"; }
log_error()   { echo -e "${RED}[$(date -u +%H:%M:%SZ)] [ERROR] ${NC}$*" >&2; _audit "ERROR" "$*"; }
log_step()    { echo -e "\n${BLUE}══ $* ══${NC}"; }
log_guide()   { echo -e "${PURPLE}  ➤ $*${NC}"; }

_audit() {
  local level=$1; local msg=$2
  # Never log key values to audit file
  local safe_msg
  safe_msg=$(echo "${msg}" | sed 's/sk_[a-zA-Z0-9_]*/[STRIPE_KEY_REDACTED]/g' | \
    sed 's/whsec_[a-zA-Z0-9_]*/[WEBHOOK_SECRET_REDACTED]/g')
  echo "{\"ts\":\"${TIMESTAMP}\",\"script\":\"${SCRIPT_NAME}\",\"env\":\"${ENV:-?}\",\"level\":\"${level}\",\"msg\":$(echo "${safe_msg}" | jq -R .)}" \
    >> "${AUDIT_LOG_FILE}" 2>/dev/null || true
}

# ── Argument parsing ──────────────────────────────────────────────────────────
parse_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --env)           ENV="$2"; shift 2 ;;
      --token)         TOKEN="$2"; shift 2 ;;
      --key-value)     KEY_VALUE="$2"; shift 2 ;;
      --service-name)  SERVICE_NAME="$2"; shift 2 ;;
      --list)          LIST_MODE=true; shift ;;
      --audit)         AUDIT_MODE=true; shift ;;
      --dry-run)       DRY_RUN=true; shift ;;
      --force)         FORCE=true; shift ;;
      --help|-h)       grep '^#' "${BASH_SOURCE[0]}" | sed 's/^# \{0,1\}//' | head -65; exit 0 ;;
      *)               log_error "Unknown argument: $1"; exit 1 ;;
    esac
  done

  [[ -z "${ENV}" ]] && { log_error "--env is required"; exit 1; }
  [[ "${ENV}" != "staging" && "${ENV}" != "production" ]] && { log_error "--env must be staging or production"; exit 1; }
}

# ── Prerequisites ─────────────────────────────────────────────────────────────
check_prerequisites() {
  log_step "Checking prerequisites"
  for cmd in aws kubectl jq openssl; do
    command -v "${cmd}" &>/dev/null && log_success "Found: ${cmd}" || { log_error "Missing: ${cmd}"; exit 2; }
  done
  aws sts get-caller-identity &>/dev/null && \
    log_success "AWS: $(aws sts get-caller-identity --query Arn --output text)" || \
    { log_error "AWS credentials invalid"; exit 2; }
  kubectl cluster-info &>/dev/null && log_success "Kubernetes cluster reachable" || \
    { log_error "kubectl cannot reach cluster"; exit 2; }
}

# ── Helpers ───────────────────────────────────────────────────────────────────
execute() {
  [[ "${DRY_RUN}" == "true" ]] && { log_warn "[DRY-RUN] Would run: $*"; return 0; }; "$@"
}

confirm() {
  [[ "${FORCE}" == "true" || "${DRY_RUN}" == "true" ]] && { log_info "Auto-confirming: $1"; return 0; }
  echo -e "\n${YELLOW}⚠  $1${NC}"; echo -n "Type 'yes' to continue: "; read -r r
  [[ "${r}" != "yes" ]] && { log_warn "Aborted."; exit 0; }
}

generate_internal_api_key() {
  # Format: lw_sk_<32 random hex chars>
  echo "lw_sk_$(openssl rand -hex 32)"
}

secure_read_key() {
  local prompt=$1
  local key_val=""

  if [[ -n "${KEY_VALUE}" ]]; then
    key_val="${KEY_VALUE}"
    log_info "Using key value from --key-value flag"
  else
    echo -e "\n${YELLOW}Enter the new key value (input will be hidden):${NC}"
    read -rsp "${prompt}: " key_val
    echo ""
  fi

  if [[ -z "${key_val}" ]]; then
    log_error "Key value cannot be empty"; exit 1
  fi

  echo "${key_val}"
}

# ── List managed tokens ───────────────────────────────────────────────────────
list_tokens() {
  log_step "Managed API Tokens — ${ENV}"
  echo ""
  echo -e "${BLUE}  Token Name                    Last Rotation        Secret ARN${NC}"
  echo -e "${BLUE}  ─────────────────────────────────────────────────────────────────────${NC}"

  for token_name in "${!SECRET_NAMES[@]}"; do
    local secret_id="${SECRET_NAMES[${token_name}]/\{ENV\}/${ENV}}"
    local last_changed="(not found)"

    if [[ "${DRY_RUN}" != "true" ]]; then
      last_changed=$(aws secretsmanager describe-secret \
        --secret-id "${secret_id}" \
        --query 'LastChangedDate' \
        --output text 2>/dev/null || echo "(not found)")
    fi

    printf "  %-30s %-20s %s\n" "${token_name}" "${last_changed}" "${secret_id}"
  done
  echo ""
}

# ── Rotate Stripe secret key ──────────────────────────────────────────────────
rotate_stripe_secret_key() {
  local token_type=$1  # stripe-secret-key | stripe-webhook-secret | stripe-restricted-key
  local secret_name="${SECRET_NAMES[${token_type}]/\{ENV\}/${ENV}}"
  local k8s_key="${K8S_SECRET_KEYS[${token_type}]}"
  local affected_service="${AFFECTED_SERVICES[${token_type}]}"
  local vendor_url="${VENDOR_URLS[${token_type}]}"
  local k8s_namespace="lomash-wood-${ENV}"

  log_step "Rotating ${token_type}"

  echo ""
  echo -e "${PURPLE}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${PURPLE}║  OPERATOR ACTION REQUIRED — Stripe Dashboard                 ║${NC}"
  echo -e "${PURPLE}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  log_guide "1. Open the Stripe Dashboard: ${vendor_url}"

  if [[ "${token_type}" == "stripe-secret-key" ]]; then
    log_guide "2. Click 'Create restricted key' or 'Roll key' on the existing secret key"
    log_guide "3. Copy the new key value (starts with sk_live_ or sk_test_)"
    log_guide "4. Do NOT revoke the old key yet — services still depend on it"
  elif [[ "${token_type}" == "stripe-webhook-secret" ]]; then
    log_guide "2. Select the webhook endpoint for ${ENV}"
    log_guide "3. Click 'Reveal signing secret' or regenerate it"
    log_guide "4. Copy the new signing secret (starts with whsec_)"
  elif [[ "${token_type}" == "stripe-restricted-key" ]]; then
    log_guide "2. Create a new restricted key with the same permissions as the current one"
    log_guide "3. Copy the new key value"
    log_guide "4. Do NOT revoke the old key yet"
  fi

  echo ""
  [[ "${FORCE}" != "true" ]] && confirm "Have you created the new ${token_type} in Stripe and are ready to paste it?"

  local new_key
  new_key=$(secure_read_key "Paste the new ${token_type}")

  # Basic format validation
  if [[ "${token_type}" == "stripe-secret-key" ]] && [[ "${new_key}" != sk_* ]]; then
    log_error "Invalid Stripe secret key format (expected sk_live_... or sk_test_...)"
    exit 1
  fi
  if [[ "${token_type}" == "stripe-webhook-secret" ]] && [[ "${new_key}" != whsec_* ]]; then
    log_error "Invalid Stripe webhook secret format (expected whsec_...)"
    exit 1
  fi

  # Store in Secrets Manager
  log_info "Storing new ${token_type} in Secrets Manager: ${secret_name}"
  execute aws secretsmanager put-secret-value \
    --secret-id "${secret_name}" \
    --secret-string "${new_key}"
  log_success "Secrets Manager updated"

  # Update Kubernetes secret
  local new_key_b64
  new_key_b64=$(echo -n "${new_key}" | base64 -w 0)
  execute kubectl patch secret "${affected_service}-third-party-secrets" \
    --namespace "${k8s_namespace}" \
    --type merge \
    --patch "{\"data\":{\"${k8s_key}\":\"${new_key_b64}\"}}" 2>/dev/null \
    || log_warn "Kubernetes secret not found — ensure it's applied via Helm values"
  log_success "Kubernetes secret updated"

  # Rolling restart
  execute kubectl rollout restart deployment "${affected_service}" \
    --namespace "${k8s_namespace}" 2>/dev/null || log_warn "Deployment not found"
  execute kubectl rollout status deployment "${affected_service}" \
    --namespace "${k8s_namespace}" --timeout="${ROLLOUT_TIMEOUT}s" 2>/dev/null || \
    log_warn "Rollout status check failed — verify manually"
  log_success "${affected_service} restarted with new ${token_type}"

  # Prompt to revoke old key
  echo ""
  echo -e "${YELLOW}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${YELLOW}║  OPERATOR ACTION REQUIRED — Revoke old key                   ║${NC}"
  echo -e "${YELLOW}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  log_guide "The new key is now active. You can safely revoke the OLD key."
  log_guide "1. Return to: ${vendor_url}"
  log_guide "2. Revoke / delete the OLD ${token_type}"
  log_guide "3. Confirm revocation is complete before proceeding"
  echo ""

  _audit "OK" "Rotated ${token_type} for env=${ENV} service=${affected_service}"
}

# ── Rotate Twilio Auth Token ──────────────────────────────────────────────────
rotate_twilio_token() {
  log_step "Rotating Twilio Auth Token"

  local secret_name="${SECRET_NAMES["twilio-auth-token"]/\{ENV\}/${ENV}}"
  local k8s_namespace="lomash-wood-${ENV}"

  echo ""
  echo -e "${PURPLE}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${PURPLE}║  OPERATOR ACTION REQUIRED — Twilio Console                   ║${NC}"
  echo -e "${PURPLE}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  log_guide "1. Open: ${VENDOR_URLS["twilio-auth-token"]}"
  log_guide "2. Create a new API Key (Standard or Main)"
  log_guide "3. Note: Twilio uses API Key SID + Secret pairs (not the Account Auth Token directly)"
  log_guide "4. Copy both the API Key SID and the Secret"
  echo ""
  confirm "Ready to enter new Twilio credentials?"

  local new_account_sid new_auth_token
  new_account_sid=$(secure_read_key "Twilio Account SID (ACxxxx)")
  new_auth_token=$(secure_read_key "Twilio Auth Token or API Key Secret")

  local secret_value
  secret_value=$(jq -nc \
    --arg sid "${new_account_sid}" \
    --arg token "${new_auth_token}" \
    '{accountSid:$sid,authToken:$token}')

  execute aws secretsmanager put-secret-value \
    --secret-id "${secret_name}" \
    --secret-string "${secret_value}"
  log_success "Twilio credentials stored in Secrets Manager"

  local token_b64
  token_b64=$(echo -n "${new_auth_token}" | base64 -w 0)
  local sid_b64
  sid_b64=$(echo -n "${new_account_sid}" | base64 -w 0)

  execute kubectl patch secret "notification-service-third-party-secrets" \
    --namespace "${k8s_namespace}" \
    --type merge \
    --patch "{\"data\":{\"TWILIO_AUTH_TOKEN\":\"${token_b64}\",\"TWILIO_ACCOUNT_SID\":\"${sid_b64}\"}}" \
    2>/dev/null || log_warn "Kubernetes secret not found"

  execute kubectl rollout restart deployment notification-service \
    --namespace "${k8s_namespace}" 2>/dev/null || log_warn "Deployment not found"
  execute kubectl rollout status deployment notification-service \
    --namespace "${k8s_namespace}" --timeout="${ROLLOUT_TIMEOUT}s" 2>/dev/null || true

  log_success "Twilio token rotation complete"
  _audit "OK" "Rotated twilio-auth-token for env=${ENV}"
}

# ── Rotate Firebase Service Account ──────────────────────────────────────────
rotate_firebase_account() {
  log_step "Rotating Firebase Service Account"

  local secret_name="${SECRET_NAMES["firebase-service-account"]/\{ENV\}/${ENV}}"
  local k8s_namespace="lomash-wood-${ENV}"

  echo ""
  echo -e "${PURPLE}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${PURPLE}║  OPERATOR ACTION REQUIRED — Firebase Console                 ║${NC}"
  echo -e "${PURPLE}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  log_guide "1. Open: ${VENDOR_URLS["firebase-service-account"]}"
  log_guide "2. Click 'Generate new private key'"
  log_guide "3. Save the downloaded JSON file"
  log_guide "4. Do NOT delete the old key yet — services still depend on it"
  echo ""
  confirm "Ready to paste the new Firebase service account JSON?"

  local new_json
  new_json=$(secure_read_key "Paste the full Firebase service account JSON (single line)")

  # Validate JSON
  if ! echo "${new_json}" | jq . &>/dev/null; then
    log_error "Invalid JSON provided for Firebase service account"; exit 1
  fi

  execute aws secretsmanager put-secret-value \
    --secret-id "${secret_name}" \
    --secret-string "${new_json}"
  log_success "Firebase service account stored in Secrets Manager"

  local json_b64
  json_b64=$(echo -n "${new_json}" | base64 -w 0)
  execute kubectl patch secret "notification-service-third-party-secrets" \
    --namespace "${k8s_namespace}" \
    --type merge \
    --patch "{\"data\":{\"FIREBASE_SERVICE_ACCOUNT_JSON\":\"${json_b64}\"}}" \
    2>/dev/null || log_warn "Kubernetes secret not found"

  execute kubectl rollout restart deployment notification-service \
    --namespace "${k8s_namespace}" 2>/dev/null || log_warn "Deployment not found"
  execute kubectl rollout status deployment notification-service \
    --namespace "${k8s_namespace}" --timeout="${ROLLOUT_TIMEOUT}s" 2>/dev/null || true

  log_success "Firebase service account rotation complete"

  log_guide "You can now delete the OLD Firebase service account key from the Firebase Console"
  _audit "OK" "Rotated firebase-service-account for env=${ENV}"
}

# ── Rotate all internal API keys ──────────────────────────────────────────────
rotate_all_internal_keys() {
  log_step "Rotating all internal service API keys"

  local k8s_namespace="lomash-wood-${ENV}"
  local services=("auth-service" "product-service" "order-payment-service"
                  "appointment-service" "content-service" "customer-service"
                  "notification-service" "analytics-service")

  for service in "${services[@]}"; do
    log_info "Generating new internal API key for ${service}..."
    local new_key
    new_key=$(generate_internal_api_key)

    local secret_name
    secret_name="${SECRET_NAMES["internal-api-key"]/\{ENV\}/${ENV}}"
    secret_name="${secret_name/\{SERVICE_NAME\}/${service}}"

    execute aws secretsmanager put-secret-value \
      --secret-id "${secret_name}" \
      --secret-string "$(jq -nc --arg key "${new_key}" --arg svc "${service}" --arg ts "${TIMESTAMP}" \
        '{apiKey:$key,service:$svc,rotatedAt:$ts}')" \
      2>/dev/null || log_warn "Secret ${secret_name} not found in Secrets Manager — skipping"

    local key_b64
    key_b64=$(echo -n "${new_key}" | base64 -w 0)
    execute kubectl patch secret "${service}-internal-credentials" \
      --namespace "${k8s_namespace}" \
      --type merge \
      --patch "{\"data\":{\"INTERNAL_API_KEY\":\"${key_b64}\"}}" \
      2>/dev/null || log_warn "Kubernetes secret for ${service} not found"

    execute kubectl rollout restart deployment "${service}" \
      --namespace "${k8s_namespace}" 2>/dev/null || true

    log_success "Internal API key rotated for ${service}"
    _audit "OK" "Internal API key rotated for service=${service} env=${ENV}"
    sleep 5  # Stagger restarts
  done

  log_info "Waiting for all deployments to stabilise..."
  for service in "${services[@]}"; do
    execute kubectl rollout status deployment "${service}" \
      --namespace "${k8s_namespace}" --timeout="${ROLLOUT_TIMEOUT}s" 2>/dev/null || true
  done
  log_success "All internal API keys rotated"
}

# ── SES SMTP rotation via IAM ─────────────────────────────────────────────────
rotate_ses_smtp() {
  log_step "Rotating AWS SES SMTP credentials via IAM"

  local secret_name="${SECRET_NAMES["ses-smtp-password"]/\{ENV\}/${ENV}}"
  local k8s_namespace="lomash-wood-${ENV}"
  local iam_user="lw-ses-${ENV}"

  log_info "Creating new IAM access key for SES user: ${iam_user}"

  if [[ "${DRY_RUN}" == "true" ]]; then
    log_warn "[DRY-RUN] Would create IAM access key for ${iam_user}"
    return 0
  fi

  # Create new access key
  local new_key_json
  new_key_json=$(aws iam create-access-key --user-name "${iam_user}")
  local new_access_key_id
  new_access_key_id=$(echo "${new_key_json}" | jq -r '.AccessKey.AccessKeyId')
  local new_secret_key
  new_secret_key=$(echo "${new_key_json}" | jq -r '.AccessKey.SecretAccessKey')

  # SES SMTP password is derived from the IAM secret access key (specific AWS formula)
  # For simplicity, store both key ID and secret; the SMTP password is the secret key encoded
  log_info "New IAM Access Key ID: ${new_access_key_id}"

  execute aws secretsmanager put-secret-value \
    --secret-id "${secret_name}" \
    --secret-string "$(jq -nc \
      --arg kid "${new_access_key_id}" \
      --arg sk "${new_secret_key}" \
      --arg region "$(aws configure get region)" \
      '{accessKeyId:$kid,secretAccessKey:$sk,region:$region}')"
  log_success "SES credentials stored in Secrets Manager"

  # List old access keys to delete
  log_info "Listing old IAM access keys for ${iam_user}..."
  local old_keys
  old_keys=$(aws iam list-access-keys --user-name "${iam_user}" \
    --query "AccessKeyMetadata[?AccessKeyId!='${new_access_key_id}'].AccessKeyId" \
    --output text)

  local smtp_b64
  smtp_b64=$(echo -n "${new_secret_key}" | base64 -w 0)
  local kid_b64
  kid_b64=$(echo -n "${new_access_key_id}" | base64 -w 0)

  execute kubectl patch secret "notification-service-third-party-secrets" \
    --namespace "${k8s_namespace}" \
    --type merge \
    --patch "{\"data\":{\"SES_ACCESS_KEY_ID\":\"${kid_b64}\",\"SES_SECRET_ACCESS_KEY\":\"${smtp_b64}\"}}" \
    2>/dev/null || log_warn "Kubernetes secret not found"

  execute kubectl rollout restart deployment notification-service \
    --namespace "${k8s_namespace}" 2>/dev/null || true
  execute kubectl rollout status deployment notification-service \
    --namespace "${k8s_namespace}" --timeout="${ROLLOUT_TIMEOUT}s" 2>/dev/null || true

  log_success "notification-service restarted with new SES credentials"

  # Delete old keys
  for old_key in ${old_keys}; do
    log_info "Deleting old IAM access key: ${old_key}"
    execute aws iam delete-access-key \
      --user-name "${iam_user}" \
      --access-key-id "${old_key}"
    log_success "Old key deleted: ${old_key}"
  done

  _audit "OK" "Rotated SES SMTP credentials for env=${ENV} iam_user=${iam_user} new_key_id=${new_access_key_id}"
}

# ── Health check ──────────────────────────────────────────────────────────────
run_health_checks() {
  log_step "Running service health checks"
  [[ "${DRY_RUN}" == "true" ]] && { log_warn "[DRY-RUN] Skipping"; return 0; }

  local k8s_namespace="lomash-wood-${ENV}"
  local all_healthy=true

  for service in order-payment-service notification-service; do
    local running_pods
    running_pods=$(kubectl get pods --namespace "${k8s_namespace}" \
      --selector "app=${service}" --field-selector status.phase=Running \
      --no-headers 2>/dev/null | wc -l)

    if [[ "${running_pods}" -gt 0 ]]; then
      log_success "${service}: ${running_pods} running pod(s)"
    else
      log_error "${service}: No running pods — check deployment!"
      all_healthy=false
    fi
  done

  [[ "${all_healthy}" == "true" ]] && log_success "All health checks passed" || return 1
}

# ── Summary ───────────────────────────────────────────────────────────────────
print_summary() {
  echo ""
  echo -e "${GREEN}╔══════════════════════════════════════════════════╗${NC}"
  echo -e "${GREEN}║   API TOKEN ROTATION COMPLETE                    ║${NC}"
  echo -e "${GREEN}╚══════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "  Token       : ${YELLOW}${TOKEN:-all-internal}${NC}"
  echo -e "  Environment : ${YELLOW}${ENV}${NC}"
  echo -e "  Timestamp   : ${TIMESTAMP}"
  echo -e "  Log file    : ${LOG_FILE}"
  echo ""
  echo -e "  ${YELLOW}Post-rotation checklist:${NC}"
  echo -e "  □ Verify service health in Grafana"
  echo -e "  □ Confirm no payment/notification errors in Loki"
  echo -e "  □ Revoke old key in vendor dashboard (if third-party rotation)"
  echo -e "  □ Update rotation schedule in this script header"
  echo -e "  □ Record rotation in security/audit-logs/"
  echo ""
  [[ "${DRY_RUN}" == "true" ]] && echo -e "  ${YELLOW}⚠  DRY-RUN — No changes were made${NC}\n"
}

# ── Main ──────────────────────────────────────────────────────────────────────
main() {
  setup_logging

  echo ""
  echo -e "${BLUE}╔══════════════════════════════════════════════════╗${NC}"
  echo -e "${BLUE}║  Lomash Wood — API Token Rotation v${SCRIPT_VERSION}          ║${NC}"
  echo -e "${BLUE}╚══════════════════════════════════════════════════╝${NC}"
  echo ""

  parse_args "$@"
  log_info "Operator: $(whoami) | Env: ${ENV} | Token: ${TOKEN:-all} | DryRun: ${DRY_RUN}"

  if [[ "${LIST_MODE}" == "true" ]]; then
    list_tokens; exit 0
  fi

  if [[ "${AUDIT_MODE}" == "true" ]]; then
    log_info "Recent token rotation events:"
    grep '"script":"rotate-api-tokens"' "${AUDIT_LOG_FILE}" 2>/dev/null | tail -20 | jq -r '"\(.ts) [\(.level)] \(.msg)"'
    exit 0
  fi

  [[ -z "${TOKEN}" ]] && { log_error "--token is required. Use --list to see options."; exit 1; }

  if [[ "${ENV}" == "production" ]]; then
    confirm "You are rotating an API token in PRODUCTION. Affected services will restart."
  fi

  check_prerequisites

  case "${TOKEN}" in
    stripe-secret-key|stripe-restricted-key|stripe-webhook-secret)
      rotate_stripe_secret_key "${TOKEN}" ;;
    twilio-auth-token)
      rotate_twilio_token ;;
    firebase-service-account)
      rotate_firebase_account ;;
    ses-smtp-password)
      rotate_ses_smtp ;;
    internal-api-key)
      [[ -z "${SERVICE_NAME}" ]] && { log_error "--service-name required for internal-api-key rotation"; exit 1; }
      rotate_all_internal_keys ;;
    all-internal)
      rotate_all_internal_keys ;;
    *)
      log_error "Unknown token: ${TOKEN}. Use --list to see valid options."; exit 1 ;;
  esac

  run_health_checks
  print_summary
  _audit "OK" "Token rotation completed. Token: ${TOKEN} Env: ${ENV}"
  exit 0
}

main "$@"